---
title: Hyperopt 超参数优化指南
subject: Freqtrade 超参数优化
subtitle: 使用 Hyperopt 优化策略参数
short_title: Hyperopt 指南
description: Hyperopt 是 Freqtrade 中用于自动化策略参数优化的工具,通过搜索最佳参数组合来提升策略性能。
tags: [超参数优化, Hyperopt, 策略优化, 机器学习, 参数调优]
categories: [策略开发]
prerequisites: [策略开发, 回测, Python基础]
difficulty: advanced
estimated_time: 120分钟
last_updated: 2024-01-15
version: 1.0
nav_order: 10
toc: true
---

# Hyperopt

本页解释了如何通过寻找最佳参数来调整您的策略，这个过程称为超参数优化。机器人使用 `optuna` 包中包含的算法来完成这项工作。
搜索将消耗所有 CPU 核心，让您的笔记本电脑听起来像战斗机，并且仍然需要很长时间。

一般来说，最佳参数的搜索从几个随机组合开始（详见[下文](#reproducible-results)），然后使用 optuna 的采样器算法之一（目前是 NSGAIIISampler）来快速找到搜索超空间中最小化[损失函数](#loss-functions)值的参数组合。

Hyperopt 需要历史数据，就像回测一样（hyperopt 使用不同参数多次运行回测）。
要了解如何获取您感兴趣的交易对和交易所的数据，请查看文档的[数据下载](data-download.md)部分。

:::{error} Hyperopt 崩溃
当只使用 1 个 CPU 核心时，Hyperopt 可能会崩溃，这在 [Issue #1133](https://github.com/freqtrade/freqtrade/issues/1133) 中被发现。
:::

:::{note} 不再需要编写单独的 hyperopt 类
自 2021.4 版本起，您不再需要编写单独的 hyperopt 类，而是可以直接在策略中配置参数。

旧方法在 2021.8 之前得到支持，并在 2021.9 中被移除。
:::

## 安装 hyperopt 依赖

由于 Hyperopt 依赖项不是运行机器人本身所必需的，它们很重，在某些平台（如树莓派）上不容易构建，因此默认不安装。

在运行 Hyperopt 之前，您需要安装相应的依赖项，如下所述。

:::{note} 不支持在树莓派上运行
由于 Hyperopt 是一个资源密集型进程，不建议也不支持在树莓派上运行。
:::

### Docker 安装

docker 镜像包含 hyperopt 依赖项，无需进一步操作。

### 简易安装脚本 (setup.sh) / 手动安装

```bash
source .venv/bin/activate
pip install -r requirements-hyperopt.txt
```

## Hyperopt 命令参考

```{include} commands/hyperopt.md
```

### Hyperopt 清单

Hyperopt 中所有任务/可能性的清单

根据您想要优化的空间，只需要以下部分：

* 使用 `space='buy'` 定义参数 - 用于入场信号优化
* 使用 `space='sell'` 定义参数 - 用于出场信号优化

:::{note} 前提
`populate_indicators` 需要创建所有空间可能使用的所有指标，否则 hyperopt 将无法工作。
:::

很少情况下，您可能还需要创建一个名为 `HyperOpt` 的[嵌套类](advanced-hyperopt.md#overriding-pre-defined-spaces)并实现：

* `roi_space` - 用于自定义 ROI 优化（如果您需要优化超空间中 ROI 参数的范围与默认值不同）
* `generate_roi_table` - 用于自定义 ROI 优化（如果您需要 ROI 表中值的范围与默认值不同，或者 ROI 表中的条目数（步骤）与默认的 4 个步骤不同）
* `stoploss_space` - 用于自定义止损优化（如果您需要优化超空间中止损参数的范围与默认值不同）
* `trailing_space` - 用于自定义追踪止损优化（如果您需要优化超空间中追踪止损参数的范围与默认值不同）
* `max_open_trades_space` - 用于自定义 max_open_trades 优化（如果您需要优化超空间中 max_open_trades 参数的范围与默认值不同）

:::{tip} 快速优化 ROI、止损和追踪止损
您可以快速优化 `roi`、`stoploss` 和 `trailing` 空间，而无需更改策略中的任何内容。

```bash
# 准备一个可用的策略。
freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily \
    --spaces roi stoploss trailing --strategy MyWorkingStrategy \
    --config config.json -e 100
```

:::

### Hyperopt 执行逻辑

Hyperopt 将首先将您的数据加载到内存中，然后为每个交易对运行一次 `populate_indicators()` 以生成所有指标，除非指定了 `--analyze-per-epoch`。

然后，Hyperopt 将分叉到不同的进程（处理器数量或 `-j <n>`），并反复运行回测，更改属于定义的 `--spaces` 的参数。

对于每组新参数，freqtrade 将首先运行 `populate_entry_trend()`，然后运行 `populate_exit_trend()`，然后运行常规回测过程来模拟交易。

回测后，结果将传递给[损失函数](#loss-functions)，该函数将评估这个结果是否比之前的结果更好或更差。  
基于损失函数结果，hyperopt 将确定下一轮回测中要尝试的下一组参数。

### 配置您的守卫和触发器

您需要在策略文件中更改两个地方来添加新的买入 hyperopt 进行测试：

* 在类级别定义 hyperopt 将要优化的参数。
* 在 `populate_entry_trend()` 中 - 使用定义的参数值而不是原始常量。

在那里您有两种不同类型的指标：1. `guards`（守卫）和 2. `triggers`（触发器）。

1. 守卫是类似"当 ADX < 10 时永不买入"或"当当前价格超过 EMA10 时永不买入"的条件。
2. 触发器是在特定时刻实际触发买入的指标，如"当 EMA5 上穿 EMA10 时买入"或"当收盘价触及布林带下轨时买入"。

:::{hint} 守卫和触发器
从技术上讲，守卫和触发器之间没有区别。
  
但是，本指南将做出这种区分，以明确信号不应该是"粘性"的。

粘性信号是在多个蜡烛期间保持活跃的信号。这可能导致在信号消失前（这意味着成功的机会比开始时低得多）才进入信号。
:::

超参优化将在每个 epoch 轮次中选择一个触发器和可能的多个守卫。

#### 出场信号优化

与上述入场信号类似，出场信号也可以优化。
将相应的设置放入以下方法中：

* 在类级别定义 hyperopt 将要优化的参数，可以通过将它们命名为 `sell_*`，或通过显式定义 `space='sell'`。
* 在 `populate_exit_trend()` 中 - 使用定义的参数值而不是原始常量。

配置和规则与买入信号相同。

## 解决一个谜题

假设您很好奇：是否应该使用 MACD 交叉或布林带下轨来触发您的做多入场。
您还想知道是否应该使用 RSI 或 ADX 来帮助做出这些决定。
如果您决定使用 RSI 或 ADX，应该为它们使用哪些值？

让我们使用超参数优化来解决这个谜题。

## 优化指标参数

假设您有一个简单的策略 - EMA 交叉策略（2 个移动平均线交叉）- 并且您想找到这个策略的理想参数。
默认情况下，我们假设止损为 5% - 止盈（`minimal_roi`）为 10% - 这意味着 freqtrade 将在达到 10% 利润时卖出交易。

```python
from pandas import DataFrame
from functools import reduce

import talib.abstract as ta

from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, 
                                IStrategy, IntParameter)
import freqtrade.vendor.qtpylib.indicators as qtpylib

class MyAwesomeStrategy(IStrategy):
    stoploss = -0.05
    timeframe = '15m'
    minimal_roi = {
        "0":  0.10
    }
    # 定义参数空间
    buy_ema_short = IntParameter(3, 50, default=5)
    buy_ema_long = IntParameter(15, 200, default=50)


    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        """生成策略使用的所有指标"""
        
        # 计算所有 ema_short 值
        for val in self.buy_ema_short.range:
            dataframe[f'ema_short_{val}'] = ta.EMA(dataframe, timeperiod=val)
        
        # 计算所有 ema_long 值
        for val in self.buy_ema_long.range:
            dataframe[f'ema_long_{val}'] = ta.EMA(dataframe, timeperiod=val)
        
        return dataframe

    def populate_entry_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        conditions = []
        conditions.append(qtpylib.crossed_above(
                dataframe[f'ema_short_{self.buy_ema_short.value}'], dataframe[f'ema_long_{self.buy_ema_long.value}']
            ))

        # 检查交易量不为 0
        conditions.append(dataframe['volume'] > 0)

        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'enter_long'] = 1
        return dataframe

    def populate_exit_trend(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        conditions = []
        conditions.append(qtpylib.crossed_above(
                dataframe[f'ema_long_{self.buy_ema_long.value}'], dataframe[f'ema_short_{self.buy_ema_short.value}']
            ))

        # 检查交易量不为 0
        conditions.append(dataframe['volume'] > 0)

        if conditions:
            dataframe.loc[
                reduce(lambda x, y: x & y, conditions),
                'exit_long'] = 1
        return dataframe
```

分解说明：

使用 `self.buy_ema_short.range` 将返回一个包含参数低值和高值之间所有条目的范围对象。
在这种情况下（`IntParameter(3, 50, default=5)`），循环将为 3 到 50 之间的所有数字运行（`[3, 4, 5, ... 49, 50]`）。
通过在循环中使用这个，hyperopt 将生成 48 个新列（`['buy_ema_3', 'buy_ema_4', ... , 'buy_ema_50']`）。

Hyperopt 本身将使用选定的值来创建买入和卖出信号。

虽然这个策略可能过于简单，无法提供稳定的利润，但它应该作为如何优化指标参数的示例。

:::{note}
`self.buy_ema_short.range` 在 hyperopt 和其他模式之间的行为会有所不同。对于 hyperopt，上面的示例可能生成 48 个新列，但是对于所有其他模式（回测、模拟/实盘），它将只为选定的值生成列。因此，您应该避免使用具有显式值的结果列（除了 `self.buy_ema_short.value` 之外的值）。
:::

:::{note}
`range` 属性也可以与 `DecimalParameter` 和 `CategoricalParameter` 一起使用。由于无限搜索空间，`RealParameter` 不提供此属性。
:::

:::{hint} 性能提示
在正常的超参优化过程中，指标被计算一次并提供给每个 epoch，随着核心数量的增加，RAM 使用量线性增加。由于这也影响性能，有两种替代方案可以减少 RAM 使用量：

* 将 `ema_short` 和 `ema_long` 计算从 `populate_indicators()` 移到 `populate_entry_trend()`。由于 `populate_entry_trend()` 将在每个 epoch 计算，您不需要使用 `.range` 功能。
* hyperopt 提供 `--analyze-per-epoch`，这将把 `populate_indicators()` 的执行移到 epoch 进程中，每个 epoch 每个参数只计算一个值，而不是使用 `.range` 功能。在这种情况下，`.range` 功能将只返回实际使用的值。

这些替代方案将减少 RAM 使用量，但会增加 CPU 使用量。但是，您的超参优化运行不太可能因为内存不足（OOM）问题而失败。

无论您使用 `.range` 功能还是上述替代方案，您都应该尝试使用尽可能小的空间范围，因为这将改善 CPU/RAM 使用量。
:::

(optimizing-protections)=

## 优化保护措施

Freqtrade 也可以优化保护措施。如何优化保护措施取决于您，以下内容仅供参考。

策略只需要将"protections"条目定义为返回保护配置列表的属性。

```python
from pandas import DataFrame
from functools import reduce

import talib.abstract as ta

from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, 
                                IStrategy, IntParameter)
import freqtrade.vendor.qtpylib.indicators as qtpylib

class MyAwesomeStrategy(IStrategy):
    stoploss = -0.05
    timeframe = '15m'
    # 定义参数空间
    cooldown_lookback = IntParameter(2, 48, default=5, space="protection", optimize=True)
    stop_duration = IntParameter(12, 200, default=5, space="protection", optimize=True)
    use_stop_protection = BooleanParameter(default=True, space="protection", optimize=True)


    @property
    def protections(self):
        prot = []

        prot.append({
            "method": "CooldownPeriod",
            "stop_duration_candles": self.cooldown_lookback.value
        })
        if self.use_stop_protection.value:
            prot.append({
                "method": "StoplossGuard",
                "lookback_period_candles": 24 * 3,
                "trade_limit": 4,
                "stop_duration_candles": self.stop_duration.value,
                "only_per_pair": False
            })

        return prot

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # ...
        
```

然后您可以按如下方式运行 hyperopt：
`freqtrade hyperopt --hyperopt-loss SharpeHyperOptLossDaily --strategy MyAwesomeStrategy --spaces protection`

:::{note}
保护空间不是默认空间的一部分，仅在使用参数 Hyperopt 接口时可用，不适用于旧版 hyperopt 接口（需要单独的 hyperopt 文件）。
如果选择了保护空间，Freqtrade 也会自动更改 "--enable-protections" 标志。
:::

:::{warning}
如果保护措施被定义为属性，配置中的条目将被忽略。
因此建议不要在配置中定义保护措施。
:::

### 从以前的属性设置迁移

从以前的设置迁移非常简单，可以通过将保护措施条目转换为属性来完成。
简单来说，以下配置将转换为下面的内容。

```python
class MyAwesomeStrategy(IStrategy):
    protections = [
        {
            "method": "CooldownPeriod",
            "stop_duration_candles": 4
        }
    ]
```

结果

```python
class MyAwesomeStrategy(IStrategy):
    
    @property
    def protections(self):
        return [
            {
                "method": "CooldownPeriod",
                "stop_duration_candles": 4
            }
        ]
```

然后您显然也会将潜在有趣的条目更改为参数，以允许超参优化。

### 优化 `max_entry_position_adjustment`

虽然 `max_entry_position_adjustment` 不是一个单独的空间，但它仍然可以通过使用上面显示的属性方法在 hyperopt 中使用。

```python
from pandas import DataFrame
from functools import reduce

import talib.abstract as ta

from freqtrade.strategy import (BooleanParameter, CategoricalParameter, DecimalParameter, 
                                IStrategy, IntParameter)
import freqtrade.vendor.qtpylib.indicators as qtpylib

class MyAwesomeStrategy(IStrategy):
    stoploss = -0.05
    timeframe = '15m'

    # 定义参数空间
    max_epa = CategoricalParameter([-1, 0, 1, 3, 5, 10], default=1, space="buy", optimize=True)

    @property
    def max_entry_position_adjustment(self):
        return self.max_epa.value
        

    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # ...
```

:::{tip} 使用 `IntParameter`
您也可以使用 `IntParameter` 进行此优化，但必须显式返回一个整数：

```python
max_epa = IntParameter(-1, 10, default=1, space="buy", optimize=True)

@property
def max_entry_position_adjustment(self):
    return int(self.max_epa.value)
```

:::

(loss-functions)=

## 损失函数

每个超参数调优都需要一个目标。这通常被定义为损失函数（有时也称为目标函数），对于更理想的结果应该减小，对于不好的结果应该增加。

损失函数必须通过 `--hyperopt-loss <Class-name>` 参数指定（或可选地通过配置中的 `"hyperopt_loss"` 键）。
这个类应该位于 `user_data/hyperopts/` 目录中的自己的文件中。

目前，以下损失函数是内置的：

* `ShortTradeDurHyperOptLoss` - （默认的旧版 Freqtrade 超参优化损失函数）- 主要用于短交易持续时间和避免损失。
* `OnlyProfitHyperOptLoss` - 只考虑利润金额。
* `SharpeHyperOptLoss` - 优化相对于标准差的交易回报的夏普比率。
* `SharpeHyperOptLossDaily` - 优化相对于标准差的**每日**交易回报的夏普比率。
* `SortinoHyperOptLoss` - 优化相对于**下行**标准差的交易回报的索提诺比率。
* `SortinoHyperOptLossDaily` - 优化相对于**下行**标准差的**每日**交易回报的索提诺比率。
* `MaxDrawDownHyperOptLoss` - 优化最大绝对回撤。
* `MaxDrawDownRelativeHyperOptLoss` - 优化最大绝对回撤，同时调整最大相对回撤。
* `MaxDrawDownPerPairHyperOptLoss` - 计算每对交易对的利润/回撤比率，并返回最差结果作为目标，强制 hyperopt 优化交易对列表中所有交易对的参数。这样，我们防止一个或多个具有良好结果的交易对夸大指标，而表现不佳的交易对不被表示，因此不被优化。
* `CalmarHyperOptLoss` - 优化相对于最大回撤的交易回报的卡玛比率。
* `ProfitDrawDownHyperOptLoss` - 通过最大利润和最小回撤目标进行优化。可以在 hyperoptloss 文件中调整 `DRAWDOWN_MULT` 变量，以在回撤目的上更严格或更灵活。
* `MultiMetricHyperOptLoss` - 通过几个关键指标进行优化，以实现平衡的性能。主要重点是最大化利润和最小化回撤，同时还考虑其他指标，如利润因子、期望比率和胜率。此外，它对交易次数少的 epoch 应用惩罚，鼓励具有足够交易频率的策略。

创建自定义损失函数在文档的[高级 Hyperopt](advanced-hyperopt.md) 部分中介绍。

## 执行 Hyperopt

一旦您更新了 hyperopt 配置，您就可以运行它。
因为 hyperopt 尝试很多组合来找到最佳参数，所以需要时间才能获得好的结果。

我们强烈建议使用 `screen` 或 `tmux` 来防止任何连接丢失。

```bash
freqtrade hyperopt --config config.json --hyperopt-loss <hyperoptlossname> --strategy <strategyname> -e 500 --spaces all
```

`-e` 选项将设置 hyperopt 将进行多少次评估。由于 hyperopt 使用贝叶斯搜索，一次运行太多 epoch 可能不会产生更好的结果。经验表明，最佳结果通常在 500-1000 epoch 后不会有太大改善。  
使用不同的随机状态进行多次运行（执行），每次运行几百个 epoch，很可能会产生不同的结果。

`--spaces all` 选项确定应该优化所有可能的参数。可能性如下所示。

:::{note}
Hyperopt 将使用 hyperopt 开始时间的时间戳存储 hyperopt 结果。
读取命令（`hyperopt-list`、`hyperopt-show`）可以使用 `--hyperopt-filename <filename>` 来读取和显示较旧的 hyperopt 结果。
您可以使用 `ls -l user_data/hyperopt_results/` 找到文件名列表。
:::

### 使用不同的历史数据源执行 Hyperopt

如果您想使用磁盘上的替代历史数据集来超参优化参数，
请使用 `--datadir PATH` 选项。默认情况下，hyperopt 使用 `user_data/data` 目录中的数据。

### 使用较小的测试集运行 Hyperopt

使用 `--timerange` 参数来更改您想要使用的测试集数量。
例如，要使用一个月的数据，将 `--timerange 20210101-20210201`（从 2021 年 1 月到 2021 年 2 月）传递给 hyperopt 调用。

完整命令：

```bash
freqtrade hyperopt --strategy <strategyname> --timerange 20210101-20210201
```

### 使用较小的搜索空间运行 Hyperopt

使用 `--spaces` 选项来限制 hyperopt 使用的搜索空间。
让 Hyperopt 优化所有内容是一个巨大的搜索空间。
通常，从只搜索初始买入算法开始可能更有意义。
或者，也许您只想为您拥有的那个很棒的新买入策略优化止损或 roi 表。

合法值是：

* `all`：优化所有内容
* `buy`：只搜索新的买入策略
* `sell`：只搜索新的卖出策略
* `roi`：只为您的策略优化最小利润表
* `stoploss`：搜索最佳止损值
* `trailing`：搜索最佳追踪止损值
* `trades`：搜索最佳最大开放交易值
* `protection`：搜索最佳保护参数（阅读[保护部分](#optimizing-protections)了解如何正确定义这些）
* `default`：`all` 除了 `trailing` 和 `protection`
* 任何上述值的空格分隔列表，例如 `--spaces roi stoploss`

当未指定 `--space` 命令行选项时使用的默认 Hyperopt 搜索空间不包括 `trailing` 超空间。我们建议您在找到、验证并将其他超空间的最佳参数粘贴到您的自定义策略中后，单独运行 `trailing` 超空间的优化。

## 理解 Hyperopt 结果

一旦 Hyperopt 完成，您可以使用结果来更新您的策略。
给定以下结果来自 hyperopt：

```text
Best result:

    44/100:    135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722%). Avg duration 180:34 min. Objective: 1.94367

Buy hyperspace params:
{
    'buy_adx': 44,
    'buy_adx_enabled': False,
    'buy_rsi': 29,
    'buy_rsi_enabled': True,
    'buy_trigger': 'bb_lower'
}
```

您应该理解这个结果如下：

* 最好的买入触发器是 `bb_lower`。
* 您不应该使用 ADX，因为 `'buy_adx_enabled': False`。
* 您应该**考虑**使用 RSI 指标 (`'buy_rsi_enabled': True`) 并且最好的值是 `29.0` (`'buy_rsi': 29.0`)

### 自动参数应用到策略

当使用 Hyperoptable 参数时，您的 hyperopt-run 结果将写入策略旁边的 json 文件（所以对于 `MyAwesomeStrategy.py`，文件将是 `MyAwesomeStrategy.json`）。  
如果使用 `hyperopt-show` 子命令，除非 `--disable-param-export` 提供给两个命令中的任何一个，否则也会更新此文件。

您的策略类也可以包含这些结果明确。只需复制 hyperopt 结果块并将其粘贴到类级别，替换旧参数（如果有）。新参数将自动在下一次策略执行时加载。

将整个 hyperopt 结果传输到您的策略将如下所示：

```python
class MyAwesomeStrategy(IStrategy):
    # 最佳参数
    buy_rsi = IntParameter(20, 40, default=30, space="buy", optimize=True)
    buy_rsi_enabled = CategoricalParameter([True, False], default=True, space="buy", optimize=True)
    buy_trigger = CategoricalParameter(["bb_lower", "macd_cross_signal", "sar_reversal"], default="bb_lower", space="buy", optimize=True)
    buy_adx = IntParameter(20, 50, default=30, space="buy", optimize=True)
    buy_adx_enabled = CategoricalParameter([True, False], default=True, space="buy", optimize=True)

    # 最佳结果
    # 买入参数
    buy_params = {
        'buy_adx': 44,
        'buy_adx_enabled': False,
        'buy_rsi': 29,
        'buy_rsi_enabled': True,
        'buy_trigger': 'bb_lower'
    }
```

:::{note}
配置文件中的值将覆盖参数文件级别的参数 - 两者都将覆盖策略中的参数。
因此优先级是：config > parameter file > strategy `*_params` > parameter default
:::

### 理解 Hyperopt ROI 结果

如果您正在优化 ROI（即如果优化搜索空间包含 'all'、'default' 或 'roi'），您的结果将如下所示并包括 ROI 表：

```text
Best result:

    44/100:    135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722%). Avg duration 180:34 min. Objective: 1.94367

ROI table:
{
    0: 0.106,
    10: 0.079,
    20: 0.053,
    30: 0.027
}
```

为了在回测和实时交易/干运行中使用这个最佳 ROI 表，复制并粘贴它作为自定义策略的 `minimal_roi` 属性值：

```python
    # 最佳 ROI 表
    minimal_roi = {
        "0":  0.106,
        "10": 0.079,
        "20": 0.053,
        "30": 0.027
    }
```

如评论中所述，您也可以将其用作配置文件中的 `minimal_roi` 设置值。

#### 默认 ROI 搜索空间

如果您正在优化 ROI，Freqtrade 为您创建了 'roi' 优化超空间——它是 ROI 表组件的超空间。默认情况下，每个由 Freqtrade 生成的 ROI 表包含 4 行（步骤）。Hyperopt 实现了自适应范围，用于 ROI 表中的值，这些值取决于使用的时间框架。默认情况下，值在以下范围内变化（对于一些最常用的时间框架，值四舍五入到小数点后三位）：

| # step | 1m     |               | 5m       |             | 1h         |               | 1d           |               |
|--------|--------|---------------|----------|-------------|------------|---------------|--------------|---------------|
| 1      | 2...12 | 0.02...0.15   | 10...60  | 0.02...0.15 | 120...720  | 0.02...0.15   | 2880...17280 | 0.02...0.15   |
| 2      | 3...18 | 0.01...0.10   | 15...90  | 0.01...0.10 | 180...1080 | 0.01...0.10   | 4320...25920 | 0.01...0.10   |
| 3      | 4...24 | 0.01...0.07   | 20...120 | 0.01...0.07 | 240...1440 | 0.01...0.07   | 5760...34560 | 0.01...0.07   |
| 4      | 6...44 | 0.0           | 30...220 | 0.0         | 360...2640 | 0.0           | 8640...63360 | 0.0           |

这些范围应该足以满足大多数情况。步骤中的分钟（ROI dict 键）按比例缩放，取决于使用的时间框架。步骤中的 ROI 值按比例缩放，取决于使用的时间框架。

如果您有 `generate_roi_table()` 和 `roi_space()` 方法，请删除它们，以利用这些自适应 ROI 表和 Freqtrade 生成的 ROI 超参优化空间。

覆盖 `roi_space()` 方法，如果您需要 ROI 表组件在其他范围内变化。覆盖 `generate_roi_table()` 和 `roi_space()` 方法并实现您自己的自定义方法，以在 hyperoptimization 期间生成 ROI 表。

这些方法的示例可以在 [overriding pre-defined spaces section](advanced-hyperopt.md#overriding-pre-defined-spaces) 中找到。

:::{note} Reduced search space
为了进一步限制搜索空间，小数限制为 3 位小数（精度为 0.001）。这通常足够了，每个比这更精确的值通常会导致过拟合结果。但是，您可以 [overriding pre-defined spaces](advanced-hyperopt.md#overriding-pre-defined-spaces) 来根据需要更改此设置。
:::

### 理解 Hyperopt Stoploss 结果

如果您正在优化止损值（即如果优化搜索空间包含 'all'、'default' 或 'stoploss'），您的结果将如下所示并包括止损：

```text
Best result:

    44/100:    135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722%). Avg duration 180:34 min. Objective: 1.94367

Stoploss: -0.0699
```

为了在回测和实时交易/干运行中使用这个最佳止损值，复制并粘贴它作为自定义策略的 `stoploss` 属性值：

```python
    # 最佳止损值
    stoploss = -0.0699
```

如评论中所述，您也可以将其用作配置文件中的 `stoploss` 设置值。

#### 默认止损搜索空间

如果您正在优化止损值，Freqtrade 为您创建了 'stoploss' 优化超空间。默认情况下，该超空间中的止损值范围为 -0.35...-0.02，足以满足大多数情况。

如果您有 `stoploss_space()` 方法，请删除它以利用 Freqtrade 生成的 Stoploss 超参优化空间。

覆盖 `stoploss_space()` 方法并定义您需要的范围，如果您需要止损值在 hyperoptimization 期间在其他范围内变化。这个方法的示例可以在 [overriding pre-defined spaces section](advanced-hyperopt.md#overriding-pre-defined-spaces) 中找到。

:::{note} Reduced search space
为了进一步限制搜索空间，小数限制为 3 位小数（精度为 0.001）。这通常足够了，每个比这更精确的值通常会导致过拟合结果。但是，您可以 [overriding pre-defined spaces](advanced-hyperopt.md#overriding-pre-defined-spaces) 来根据需要更改此设置。
:::

### 理解 Hyperopt Trailing Stop 结果

如果您正在优化追踪止损值（即如果优化搜索空间包含 'all' 或 'trailing'），您的结果将如下所示并包括追踪止损参数：

```text
Best result:

    44/100:    135 trades. Avg profit  0.57%. Total profit  0.03871918 BTC (0.7722%). Avg duration 180:34 min. Objective: 1.94367

Trailing stop:
{
    'trailing_stop': True,
    'trailing_stop_positive': 0.0201,
    'trailing_stop_positive_offset': 0.0547,
    'trailing_only_offset_is_reached': True
}
```

为了在回测和实时交易/干运行中使用这些最佳追踪止损参数，复制并粘贴它们作为自定义策略的相应属性值：

```python
    # 追踪止损
    # 如果配置文件包含相应的值，这些属性将被覆盖。
    trailing_stop = True
    trailing_stop_positive = 0.0201
    trailing_stop_positive_offset = 0.0547
    trailing_only_offset_is_reached = True
```

如评论中所述，您也可以将其用作配置文件中的相应设置值。

#### 默认追踪止损搜索空间

如果您正在优化追踪止损值，Freqtrade 为您创建了 'trailing' 优化超空间。默认情况下，`trailing_stop` 参数在该超空间中始终设置为 True，`trailing_only_offset_is_reached` 值在 True 和 False 之间变化，`trailing_stop_positive` 和 `trailing_stop_positive_offset` 参数在 0.02...0.35 和 0.01...0.1 范围内变化，足以满足大多数情况。

覆盖 `trailing_space()` 方法并定义您需要的范围，如果您需要值在 hyperoptimization 期间在其他范围内变化。这个方法的示例可以在 [overriding pre-defined spaces section](advanced-hyperopt.md#overriding-pre-defined-spaces) 中找到。

:::{note} Reduced search space
为了进一步限制搜索空间，小数限制为 3 位小数（精度为 0.001）。这通常足够了，每个比这更精确的值通常会导致过拟合结果。但是，您可以 [overriding pre-defined spaces](advanced-hyperopt.md#overriding-pre-defined-spaces) 来根据需要更改此设置。
:::

(reproducible-results)=

### 可重复的结果

最佳参数搜索从参数空间中的几个（目前是 30）随机组合开始，随机 Hyperopt 轮次。这些随机轮次在 Hyperopt 输出中的第一列中用星号字符 (`*`) 标记。

这些随机值的初始状态（随机状态）由 `--random-state` 命令行选项的值控制。您可以将其设置为任意值，以获得可重复的结果。

如果您没有在命令行选项中明确设置此值，Hyperopt 会为您提供一些随机值。每个 Hyperopt 运行的随机状态值显示在日志中，因此您可以复制并粘贴它到 `--random-state` 命令行选项中，以重复使用初始随机轮次集。

如果您没有更改命令行选项、配置、时间范围、策略和 Hyperopt 类、历史数据和损失函数，您应该获得相同的超参优化结果，使用相同的随机状态值。

## 输出格式化

默认情况下，hyperopt 打印彩色结果——利润为正的 epoch 以绿色打印。此高亮帮助您找到可以稍后分析的有趣 epoch。利润为零或利润为负（损失）的 epoch 以正常颜色打印。如果您不需要结果的颜色化（例如，当您将 hyperopt 输出重定向到文件时），您可以通过在命令行中指定 `--no-color` 选项来切换颜色化。

您可以使用 `--print-all` 命令行选项，如果您想在 hyperopt 输出中看到所有结果，而不仅仅是最佳结果。当 `--print-all` 被使用时，当前最佳结果也默认高亮显示——它们以粗体（亮）样式打印。此功能也可以通过 `--no-color` 命令行选项关闭。

:::{note} Windows 和颜色输出
Windows 不支持颜色输出，因此默认禁用。要为在 Windows 下运行的 hyperopt 获得颜色输出，请考虑使用 WSL。
:::

## 位置堆叠和禁用最大市场位置

在某些情况下，您可能需要运行 Hyperopt（和回测）与 `--eps`/`--enable-position-staking` 参数，或者您可能需要将 `max_open_trades` 设置为非常高的数字以禁用对打开交易的限制。

默认情况下，hyperopt 模仿 Freqtrade Live Run/Dry Run 的行为，其中仅允许每对一个打开交易。所有对的交易总数也受 `max_open_trades` 设置的限制。在 Hyperopt/Backtesting 期间，这可能导致潜在的交易被已打开的交易隐藏（或屏蔽）。

`--eps`/`--enable-position-stacking` 参数允许模拟多次购买同一对。使用 `--max-open-trades` 与非常高的数字将禁用对打开交易的限制。

:::{note}
Dry/live runs 将 **NOT** 使用位置堆叠——因此也有意义也验证策略而没有它更接近现实。
:::

您还可以在配置文件中通过明确设置 `"position_stacking"=true` 来启用位置堆叠。

## 内存错误

由于 hyperopt 消耗大量内存（每次并行回测过程需要一次将完整数据加载到内存中），您可能会遇到 "内存不足" 错误。
为了应对这些，您有多种选择：

* 减少对数。
* 减少使用的时间范围（`--timerange <timerange>`）。
* 避免使用 `--timeframe-detail`（这会加载大量额外数据到内存中）。
* 减少并行进程的数量（`-j <n>`）。
* 增加机器的内存。
* 如果您使用大量具有 `.range` 功能的参数，请使用 `--analyze-per-epoch`。

## 目标已经在此点之前评估过

如果您看到 `The objective has been evaluated at this point before.` - 那么这是一个信号，您的空间已经耗尽，或者接近耗尽。
基本上空间中的所有点都已被击中（或局部最小值已被击中） - 并且 hyperopt 不再在多维空间中尝试尚未尝试的点。
Freqtrade 尝试通过使用新的、随机化的点来解决 "局部最小值" 问题。

示例：

```python
buy_ema_short = IntParameter(5, 20, default=10, space="buy", optimize=True)
# 这是买入空间中唯一的参数
```

买入空间有 15 个可能的值（`5, 6, ... 19, 20`）。如果您现在运行买入空间的超参优化，hyperopt 将只有 15 个值可以尝试，然后运行完选项。
因此，您的 epoch 应该与可能的值对齐 - 或者您应该准备好中断运行，如果您注意到很多 `The objective has been evaluated at this point before.` 警告。

## 显示 Hyperopt 结果的详细信息

在您运行 Hyperopt 以获得所需的 epoch 数量后，您可以稍后列出所有结果进行分析，仅选择最佳或盈利一次，并显示以前评估的任何 epoch 的详细信息。这可以通过 `hyperopt-list` 和 `hyperopt-show` 子命令完成。这些子命令的使用在 [实用工具子集相关](utils.md#list-hyperopt-results) 章节中描述。

## 输出来自策略的调试消息

如果您想输出策略的调试消息，您可以使用 `logging` 模块。默认情况下，Freqtrade 将输出所有级别为 `INFO` 或更高的消息。

```python
import logging

class MyAwesomeStrategy(IStrategy):
    def populate_indicators(self, dataframe: DataFrame, metadata: dict) -> DataFrame:
        # 这将输出到日志文件
        logging.info("计算指标")
        # 这将输出到日志文件
        logging.debug("计算指标 - 调试级别")
        # 这将输出到日志文件
        logging.warning("计算指标 - 警告级别")
        # 这将输出到日志文件
        logging.error("计算指标 - 错误级别")
        # 这将输出到日志文件
        logging.critical("计算指标 - 严重级别")
        return dataframe
```

:::{note}
不推荐使用 `print()` 函数，因为它会干扰 hyperopt 的输出。
建议使用 `logging` 模块代替。
:::

## 验证回测结果

一旦优化策略实现到您的策略中，您应该回测此策略，以确保一切按预期工作。

为了获得与 Hyperopt 期间相同的相同结果（交易次数、持续时间、利润等），请使用与 Hyperopt 相同的配置和参数（时间范围、时间框架、...）进行回测。

### 为什么我的回测结果与我的 Hyperopt 结果不匹配？

如果结果不匹配，请检查以下因素：

* 您可能已在 `populate_indicators()` 中添加了参数，这些参数仅在 **所有 epoch** 中计算一次。如果您是，例如，尝试优化多个 SMA 时间周期值，hyperoptable 时间周期参数应放置在 `populate_entry_trend()` 中，该参数在每个 epoch 中计算。请参阅 [Optimizing an indicator parameter](https://www.freqtrade.io/en/stable/hyperopt/#optimizing-an-indicator-parameter)。
* 如果您已禁用自动将 hyperopt 参数导出到 JSON 参数文件中，请双检查以确保您已将所有 hyperopted 值传输到策略中。
* 检查日志以验证设置了哪些参数以及使用了哪些值。
* 特别注意止损、max_open_trades 和追踪止损参数，因为这些参数通常在配置文件中设置，这些参数会覆盖对策略的更改。检查您的回测日志以确保没有参数无意中由配置设置（如 `stoploss`、`max_open_trades` 或 `trailing_stop`）。
* 验证您是否没有意外的参数 JSON 文件覆盖策略参数或策略中的默认 hyperopt 设置。
* 验证如果您在回测中启用的任何保护措施在 hyperopting 时也已启用，反之亦然。当使用 `--space protection` 时，保护措施自动为 hyperopting 启用。
